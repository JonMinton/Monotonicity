{
    "contents" : "rm(list=ls())\n\nsetwd(\"X:/Manuscripts/03 To Submit/Monotonicity/Manuscript for Submission/Figures/\")\n#load(\"MattData.rData\")\nrequire(MASS)\n\n\nData.2D <- data.frame(\n  U1=\n    c(0.736, 0.698, 0.756, 0.638, 0.646,\n      0.619, 0.800, 0.411, 0.664, 0.513,\n      0.594, 0.371, 0.608, 0.528, 0.823,\n      0.682, 0.462, 0.576, 0.572, 0.607,\n      0.542, 0.625, 0.694, 0.512, 0.591,\n      0.559, 0.588, 0.766, 0.551, 0.256\n    ),\n  U2=\n    c(0.700, 0.625, 0.719, 0.594, 0.565,\n      0.565, 0.779, 0.363, 0.540, 0.500,\n      0.532, 0.300, 0.572, 0.420, 0.810,\n      0.650, 0.457, 0.517, 0.495, 0.561,\n      0.481, 0.610, 0.603, 0.463, 0.551,\n      0.450, 0.550, 0.647, 0.491, 0.150\n    )\n)\n\nmean(Data.2D$U1);mean(Data.2D$U2)\n\nN.U1 <- length(Data.2D$U1)\nN.U2 <- length(Data.2D$U2)\n\n#find 95% CI for U1 and U2\nu1.low<-mean(Data.2D$U1)-1.96*sd(Data.2D$U1)/sqrt(N.U1)\nu1.up<-mean(Data.2D$U1)+1.96*sd(Data.2D$U1)/sqrt(N.U2)\n\nu2.low<-mean(Data.2D$U2)-1.96*sd(Data.2D$U2)/sqrt(N.U1)\nu2.up<-mean(Data.2D$U2)+1.96*sd(Data.2D$U2)/sqrt(N.U2)\n\nu1.low;u1.up;u2.low;u2.up\n# reproduce figure 1\n\ntiff(\"Fig1.tiff\", 400, 400)\nplot(U2 ~ U1, data=Data.2D, xlim=c(0,1), ylim=c(0,1), \n     xlab=expression(italic(U)[1]), \n     ylab=expression(italic(U)[2])\n     )\nabline(0,1)\ndev.off()\n\n\n# What is the true variance-covariance of the datasets?\n\ncov(Data.2D)\ncor(Data.2D)\n\n# Quick example to show why methods 3 and 4 will produce biased means.\n\n#norm.untruncated <- rnorm(1000, 0, 1)\n#norm.truncated <- norm.untruncated\n#norm.truncated[norm.untruncated < -0.5] <- -0.5\n\n\n#cov(Data.3D)\n#cor(Data.3D)\n\n# The data themselves. This is the only information available to the\n# ten methods, in addition to direction of the monotonic relationship:\n\n# Note: the sds are standard deivations of the means - i.e. standard errors\nU1.summary <- list(mu=round(mean(Data.2D$U1),3), sd=(round(u1.up,3) - round(mean(Data.2D$U1),3))/1.96)\nU2.summary <- list(mu=round(mean(Data.2D$U2),3), sd=(round(u2.up,3) - round(mean(Data.2D$U2),3))/1.96)\n\n\n\n############################################################################################################################\n######################## METHODS ###########################################################################################\n############################################################################################################################\n\n## Method 1 : Independent Sampling (Naive)\n## Method 2 : Quantile matching/same random number seed\n## Method 3 : Upward Replacement\n## Method 4 : Downward Replacement\n## Method 5 : Upward Resampling\n## Method 6 : Downward Resampling\n## Method 7 : AIVM Covariance\n## Method 8 : Lower bounded covariance retrofitting\n## Method 9 : Upper Bounded covariance retrofitting\n## Method 10: Beta distribution difference modelling\n\n# 2d case first, then 3d case\n\n# changed my mind: now just going to look at 2d case\n\n############################################################################################################################\n\nn.PSA <- 1000\n\n# Bootstrapping for comparison\n\nmethodBoot.PSA <- matrix(NA, ncol=2, nrow=n.PSA)\n\nfor (i in 1:n.PSA){\n  draws <- 1: dim(Data.2D)[1]\n  size=dim(Data.2D)[1]\n  tmp <- Data.2D[sample(draws, size, T),]\n  methodBoot.PSA[i,] <- c(mean(tmp[,1]), mean(tmp[,2]))\n}\nmethodBoot.PSA <- data.frame(methodBoot.PSA)\nnames(methodBoot.PSA) <- c(\"u1\",\"u2\")\n\ntiff(\"Fig2 PSA_boot.tiff\",400, 400)\nplot(u2 ~ u1, data=methodBoot.PSA, \n     xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),\n     xlim=c(0.45, 0.7), ylim=c(0.45,0.7), main=\"\")\nabline(0,1)\ndev.off()\n\n\nestBeta <- function(mu, var) {\n  a <- mu * ((1 - mu) * (mu / var) - 1)\n  b <- a * ((1 - mu) / mu)\n  return(list(a=a, b=b))\n}\n# METHOD 1: INDEPENDENT SAMPLING\n\nu1.param <- estBeta(U1.summary$mu, U1.summary$sd^2)\nu2.param <- estBeta(U2.summary$mu, U2.summary$sd^2)\n\nPSA.method01 <-  data.frame(u1=rbeta(n.PSA,\n                                     u1.param$a,\n                                     u1.param$b\n                                     ),\n                               u2=rbeta(n.PSA,\n                                     u2.param$a,\n                                     u2.param$b\n                                     )\n                            )\n\nplot(u2 ~ u1, data=PSA.method01, xlim=c(0.45, 0.7), ylim=c(0.45,0.7))\nabline(0,1)\n\n# METHOD 2: SAME RANDOM NUMBER SEED\n\n# Illustration of issue with random number stream and beta distribution\n\n# non-problematic run:\n\nset.seed(80)\nu1 <- rbeta(n.PSA, \n            u1.param$a,\n            u1.param$b\n            )\n\nset.seed(80)\nu2 <- rbeta(n.PSA, \n            u2.param$a,\n            u2.param$b\n            )\n\n\nPSA.method02 <-  data.frame(u1=u1, u2=u2)\nrm(u1, u2)\n\nplot(u2 ~ u1, data=PSA.method02, xlim=c(0.45, 0.7), ylim=c(0.45,0.7))\nabline(0,1)\n\n\n# METHOD 3: UPWARD REPLACEMENT\n\nu1 <- rbeta(n.PSA, u1.param$a, u1.param$b)\nu2 <- rbeta(n.PSA, u2.param$a, u2.param$b)\n\nu1[u1 < u2] <- u2[u1 < u2]\nPSA.method03 <- data.frame(u1=u1, u2=u2)\nrm(u1, u2)\nplot(u2 ~ u1, data=PSA.method03, xlim=c(0.45, 0.7), ylim=c(0.45,0.7))\nabline(0,1)\n\n# METHOD 4: DOWNWARD REPLACEMENT\n\nu1 <- rbeta(n.PSA, u1.param$a, u1.param$b)\nu2 <- rbeta(n.PSA, u2.param$a, u2.param$b)\nu2[u2 > u1] <- u1[u2 > u1]\n\nPSA.method04 <- data.frame(u1=u1, u2=u2)\nrm(u1, u2)\n\nplot(u2 ~ u1, data=PSA.method04, xlim=c(0.45, 0.7), ylim=c(0.45,0.7))\nabline(0,1)\n\n\n# METHOD 5: UPWARDS RESAMPLING\n\nu1 <- rbeta(n.PSA, u1.param$a, u1.param$b)\nu2 <- rep(NA, n.PSA)\n\nfor (i in 1:n.PSA){\n  continue <- F\n  while(continue==F){\n    this.u2 <- rbeta(1, u2.param$a, u2.param$b)\n    if (this.u2 < u1[i]){\n      u2[i] <- this.u2\n      continue <- T\n    }\n  }\n}\n\nPSA.method05 <- data.frame(u1=u1, u2=u2)\n\nrm(u1, u2)\nplot(u2 ~ u1, data=PSA.method05, xlim=c(0.45, 0.7), ylim=c(0.45,0.7))\nabline(0,1)\n\n# METHOD 6: DOWNWARDS RESAMPLING [?]\n\nu1 <- rep(NA, n.PSA)\nu2 <- rbeta(n.PSA, u2.param$a, u2.param$b)\n\nfor (i in 1:n.PSA){\n  continue <- F\n  while(continue==F){\n    this.u1 <- rbeta(1, u1.param$a, u1.param$b)\n    if (this.u1 > u2[i]){\n      u1[i] <- this.u1\n      continue <- T\n    }\n  }\n}\n\nPSA.method06 <- data.frame(u1=u1, u2=u2)\n\nrm(u1, u2)\n\n# METHOD 7: AIVM COVARIANCE\n\n# Correlation(X, Y) := covariance (X, Y) / (sd(X) * sd(Y))\n# So, when correlation = 1\n# covariance(X, y) = sd(X) * sd(Y)\n# This defines the upper limit on the values\n\n# Function\nrequire(MASS)\nMakeAIVMCov.2d <- function(mu.X, sd.X, mu.Y, sd.Y, n.psa=n.PSA){\n  varX <- sd.X^2\n  varY <- sd.Y^2\n\n  aivm <- min(\n    mean(\n      c(varX, varY)\n      ),\n    sd.X * sd.Y)\n\n  sig <- matrix(data=c(varX, aivm, aivm, varY), nrow=2, byrow=T)\n\n  aivm.samples <-   mvrnorm(n=n.psa, mu=c(mu.X, mu.Y), Sigma=sig )\n  colnames(aivm.samples) <- c(\"X.sampled\", \"Y.sampled\")\n  aivm.samples <- as.data.frame(aivm.samples)\n  return(list(aivm.samples=aivm.samples, aivm=aivm))\n}\n\ntmp <- MakeAIVMCov.2d(\n  mu.X=U1.summary$mu,\n  sd.X=U1.summary$sd,\n  mu.Y=U2.summary$mu,\n  sd.Y=U2.summary$sd  \n  )\n\nPSA.method07 <- tmp$aivm.samples\nnames(PSA.method07) <- c(\"u1\", \"u2\")\n\n#plot(u2 ~ u1, data=PSA.method07)\n\n# METHOD 8: Lower Bounded Covariance Retrofitting\n# METHOD 9: Upper Bounded Covariance Retrofitting\n\n# Lowerbounded (method 8) : use upper=F\n# Otherwise (method 9) use default:  upper=T\nMakeBCVR.2d <- function(mu.X, sd.X, mu.Y, sd.Y, n.psa=n.PSA, incBy=0.00001, upper=T){\n  require(MASS)\n\n  varX <- sd.X^2 # variance of X\n  varY <- sd.Y^2 # variance of Y\n  if(upper==T){\n    lowerbound <- 0 # start assuming independent\n    upperbound <- min(sd.X * sd.Y,\n                      mean(varX, varY)\n    ) # upper bounds are the minimum of the AIVM or the cov which implies a cor > 1\n  } else {\n    lowerbound <- mean(varX, varY)\n    upperbound <- sd.X * sd.Y # don't select a covariance which implies a correlation > 1\n  }\n\n\n\n  this.cov <- lowerbound\n  cat(varX, varY, lowerbound, upperbound, this.cov, \"\\n\")\n  mus <- c(mu.X, mu.Y)\n  search <- T\n\n  if(this.cov==upperbound){ # if the maximum value's been reached already\n\n    cat(\"Upperbound already reached\\n\")\n    search <- F # if the upper limit's already been reached, go no further\n    testsig <- matrix(c(varX, this.cov, this.cov, varY), nrow=2, byrow=T)\n    testsamples <- mvrnorm(n.psa, mu=mus, Sigma=testsig)\n  } else {\n    cat(\"Upperbound not yet reached\\n\")\n    this.cov <- lowerbound\n    cat(\"This covariance: \", this.cov, \"\\n\", sep=\"\")\n    testsig <- matrix(c(varX, this.cov, this.cov, varY), nrow=2, byrow=T)\n    testsamples <- mvrnorm(n.psa, mu=mus, Sigma=testsig)\n  }\n\n  while(search==T){\n    cat(\"trying \", this.cov, \"\\n\")\n    testsig <- matrix(c(varX, this.cov, this.cov, varY), nrow=2, byrow=T)\n    try.testsamples <- try(mvrnorm(n.psa, mu=mus, Sigma=testsig))\n    if(class(try.testsamples)==\"try-error\"){ # if mvrnorm has been passed impossible values\n      search <- F\n      cat(\"Error picked up\\n\")\n\n    } else {\n      cat(\"No error in mvrnorm args\\n\")\n      testsamples <- try.testsamples # if the attempted values are correct, use them\n      if (any(testsamples[,1] < testsamples[,2])){\n        cat(\"Violation with \", this.cov, \"\\n\")\n        this.cov <- this.cov + incBy # increment the values by a little bit\n        cat(\"Trying \", this.cov, \"\\n\")\n      } else {\n        cat(\"Found \", this.cov, \"\\n\")\n        search <- F\n      }\n    }\n  }\n  this.cor <- this.cov / (sd.X * sd.Y)\n  return(list(cov=this.cov, samples=testsamples, cor=this.cor))\n}\n\ntmp <- MakeBCVR.2d(\n  mu.X=U1.summary$mu,\n  sd.X=U1.summary$sd,\n  mu.Y=U2.summary$mu,\n  sd.Y=U2.summary$sd,\n  upper=F\n)\n\nmethod08.cov <- tmp$cov\nmethod08.cor <- tmp$cor\n\n\nPSA.method08 <-data.frame(tmp$samples)\n\nnames(PSA.method08) <- c(\"u1\", \"u2\")\n\ntmp <- MakeBCVR.2d(\n  mu.X=U1.summary$mu,\n  sd.X=U1.summary$sd,\n  mu.Y=U2.summary$mu,\n  sd.Y=U2.summary$sd\n)\n\nmethod09.cov <- tmp$cov\nmethod09.cor <- tmp$cor\n\n\nPSA.method09 <- data.frame(tmp$samples)\nnames(PSA.method09) <- c(\"u1\", \"u2\")\n\n\nplot(u2 ~ u1, data=PSA.method08)\nplot(u2 ~ u1, data=PSA.method09)\n\n# METHOD 10: Beta distribution difference fitting\n\ngetDifParam <- function(u1.mu, u1.sd, u2.mu, u2.sd, quietly=T){\n  mu <- u1.mu - u2.mu\n  \n  sigma2 <- ifelse(u1.sd > u2.sd, u1.sd^2 - u2.sd^2, u2.sd^2 - u1.sd^2)\n  x <- (1 - mu) / mu\n  \n  a <- (x/sigma2-1-2*x-x^2)/(1+3*x+3*x^2+x^3)\n  b<-a*x\n  \n  if(quietly==F){\n    print(a/(a+b))  # check mean of delta\n    print(a*b/(a+b)^2/(a+b+1))  # check variance of delta    \n  }\n  return(list(a=a, b=b))\n}\n\nDifParams <- getDifParam(U1.summary$mu, U1.summary$sd, U2.summary$mu, U2.summary$sd)\n\n\nn.PSA <- 1000\n#rU2.raw <- rnorm(n.PSA, U2.summary$mu, U2.summary$sd)\nrU2.raw <- rbeta(n.PSA, u2.param$a, u2.param$b)\n#rU1 <- rnorm(n.PSA, U1.summary$mu, U1.summary$sd)\nrU1 <- rbeta(n.PSA, u1.param$a, u1.param$b)\n\nrdelta<-rbeta(n.PSA,DifParams$a,DifParams$b)\nrU2<-rU1-rdelta\n\n\ntiff(\"Fig3 Dif_comparison.tiff\", 500, 500)\nplot(\n  density(rU1), \n  xlim=c(0.4, 0.7), \n  ylim=c(0,20), \n  main=\"\", \n  xlab=expression(italic(U)), \n  ylab=\"Density of simulated values\")\nlines(density(rU2), lty=\"dashed\")\nlines(density(rU2.raw), lwd=2, lty=\"dashed\")\nlegend(\"topleft\", \n       legend=c(\n         expression(italic(U)[1]), \n         expression(paste(italic(U)[2], \" using difference method\")), \n         expression(paste(italic(U)[2], \" using independent sampling\"))\n         ), \n       lwd=c(1,1,2), \n       lty=c(\"solid\", \"dashed\", \"dashed\"))\ndev.off()\n\n\nPSA.method10 <- data.frame(u1 = rU1, u2=rU2)\n\n####################################### RESULTS ############################################\n\n# want to plot scatter\n\n\n# want bootstrapped estimates of means to compare\n\n\n# packaging results together in list to make them easier to automate\n\nMethodsBlock <- list(\n  methodboot=methodBoot.PSA,\n  method01=PSA.method01,\n  method02=PSA.method02,\n  method03=PSA.method03,\n  method04=PSA.method04,\n  method05=PSA.method05,\n  method06=PSA.method06,\n  method07=PSA.method07,\n  method08=PSA.method08,\n  method09=PSA.method09,\n  method10=PSA.method10)\n\n\n# scatterplots\n\n# do this as a single file\n\ntiff(\"Fig4 PSA_all.tiff\", 900, 1200)\n\nsplit.screen(c(4,3))\n\nscreen(1)\nplot(u2 ~ u1, data=MethodsBlock$methodboot, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),  \n     xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),\n     main=\"a) Bootstrapped\")\nabline(0,1)\n\nscreen(3)\nplot(u2 ~ u1, data=MethodsBlock$method01, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),  \n     xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),\n     main=\"b) Method 1\")\nabline(0,1)\n\nscreen(4)\nplot(u2 ~ u1, data=MethodsBlock$method02, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),  \n     xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),\n     main=\"c) Method 2\")\nabline(0,1)\n\nscreen(5)\nplot(u2 ~ u1, data=MethodsBlock$method03, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),  \n     xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),\n     main=\"d) Method 3\")\nabline(0,1)\n\nscreen(6)\nplot(u2 ~ u1, data=MethodsBlock$method04, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),  \n     xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),\n     main=\"e) Method 4\")\nabline(0,1)\n\nscreen(7)\nplot(u2 ~ u1, data=MethodsBlock$method05, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),  \n     xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),\n     main=\"f) Method 5\")\nabline(0,1)\n\nscreen(8)\nplot(u2 ~ u1, data=MethodsBlock$method06, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),  \n     xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),\n     main=\"g) Method 6\")\nabline(0,1)\n\nscreen(9)\nplot(u2 ~ u1, data=MethodsBlock$method07, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),  \n     xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),\n     main=\"h) Method 7\")\nabline(0,1)\n\n\nscreen(10)\nplot(u2 ~ u1, data=MethodsBlock$method08, xlim=c(0.45, 0.7), ylim=c(0.45,0.7), \n     xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),\n     main=\"i) Method 8\")\nabline(0,1)\n\nscreen(11)\nplot(u2 ~ u1, data=MethodsBlock$method09, xlim=c(0.45, 0.7), ylim=c(0.45,0.7), \n     xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),\n     main=\"j) Method 9\")\nabline(0,1)\n\nscreen(12)\nplot(u2 ~ u1, data=MethodsBlock$method10, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),  \n     xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),\n     main=\"k) Method 10\")\nabline(0,1)\nclose.screen(1:12, T)\n\ndev.off()\n\n\n# # VIOLIN PLOTS\n# \n# require(vioplot)\n# \n# # Distribution of U1s\n# tiff(\"Fig5 Vioplot_u1.tiff\", 1000, 800)\n# vioplot(MethodsBlock[[\"methodboot\"]]$u1,\n#         MethodsBlock[[\"method01\"]]$u1,\n#         MethodsBlock[[\"method02\"]]$u1,\n#         MethodsBlock[[\"method03\"]]$u1,\n#         MethodsBlock[[\"method04\"]]$u1,\n#         MethodsBlock[[\"method05\"]]$u1,\n#         MethodsBlock[[\"method06\"]]$u1,\n#         MethodsBlock[[\"method07\"]]$u1,\n#         MethodsBlock[[\"method08\"]]$u1,\n#         MethodsBlock[[\"method09\"]]$u1,\n#         MethodsBlock[[\"method10\"]]$u1,\n# \n#         names=c(\"Boot\", 1:10),\n#         col=\"grey\"\n#         )\n# abline(v=1.5, lwd=2)\n# abline(h=mean(MethodsBlock[[\"methodboot\"]]$u1), lty=\"dashed\")\n# dev.off()\n# \n# # Distribution of U2s\n# tiff(\"Fig6 Vioplot_u2.png\", 1000, 800)\n# vioplot(MethodsBlock[[\"methodboot\"]]$u2,\n#         MethodsBlock[[\"method01\"]]$u2,\n#         MethodsBlock[[\"method02\"]]$u2,\n#         MethodsBlock[[\"method03\"]]$u2,\n#         MethodsBlock[[\"method04\"]]$u2,\n#         MethodsBlock[[\"method05\"]]$u2,\n#         MethodsBlock[[\"method06\"]]$u2,\n#         MethodsBlock[[\"method07\"]]$u2,\n#         MethodsBlock[[\"method08\"]]$u2,\n#         MethodsBlock[[\"method09\"]]$u2,\n#         MethodsBlock[[\"method10\"]]$u2,\n# \n#         names=c(\"Boot\", 1:10),\n#         col=\"grey\"\n# )\n# abline(v=1.5, lwd=2)\n# abline(h=mean(MethodsBlock[[\"methodboot\"]]$u2), lty=\"dashed\")\n# dev.off()\n# \n# \n# # Distribution of differences\n# tiff(\"Fig7 Vioplot_difs.png\", 1000, 800)\n# vioplot(with(MethodsBlock[[\"methodboot\"]], (u1 - u2)),\n#         with(MethodsBlock[[\"method01\"]], (u1 - u2)),\n#         with(MethodsBlock[[\"method02\"]], (u1 - u2)),\n#         with(MethodsBlock[[\"method03\"]], (u1 - u2)),\n#         with(MethodsBlock[[\"method04\"]], (u1 - u2)),\n#         with(MethodsBlock[[\"method05\"]], (u1 - u2)),\n#         with(MethodsBlock[[\"method06\"]], (u1 - u2)),\n#         with(MethodsBlock[[\"method07\"]], (u1 - u2)),\n#         with(MethodsBlock[[\"method08\"]], (u1 - u2)),\n#         with(MethodsBlock[[\"method09\"]], (u1 - u2)),\n#         with(MethodsBlock[[\"method10\"]], (u1 - u2)),\n# \n#         lwd=1.5,\n#         names=c(\"Boot\", 1:10),\n#         col=\"grey\"\n# )\n# abline(v=1.5, lwd=2)\n# abline(h=mean(with(MethodsBlock[[\"methodboot\"]], (u1 - u2))), lty=\"dashed\")\n# abline(h=0)\n# dev.off()\n\n\n# Violin plots as one image\n\n\nrequire(vioplot)\ntiff(\"Fig5 Vioplot_all.tiff\", 1000, 1500)\n\nsplit.screen(c(3,1))\n\nscreen(1)\n# Distribution of U1s\nvioplot(MethodsBlock[[\"methodboot\"]]$u1,\n        MethodsBlock[[\"method01\"]]$u1,\n        MethodsBlock[[\"method02\"]]$u1,\n        MethodsBlock[[\"method03\"]]$u1,\n        MethodsBlock[[\"method04\"]]$u1,\n        MethodsBlock[[\"method05\"]]$u1,\n        MethodsBlock[[\"method06\"]]$u1,\n        MethodsBlock[[\"method07\"]]$u1,\n        MethodsBlock[[\"method08\"]]$u1,\n        MethodsBlock[[\"method09\"]]$u1,\n        MethodsBlock[[\"method10\"]]$u1,\n#        main=\"U1\",\n        names=c(\"Boot\", 1:10),\n        col=\"grey\"\n)\nabline(v=1.5, lwd=2)\nabline(h=mean(MethodsBlock[[\"methodboot\"]]$u1), lty=\"dashed\")\n\nscreen(2)\n# Distribution of U2s\nvioplot(MethodsBlock[[\"methodboot\"]]$u2,\n        MethodsBlock[[\"method01\"]]$u2,\n        MethodsBlock[[\"method02\"]]$u2,\n        MethodsBlock[[\"method03\"]]$u2,\n        MethodsBlock[[\"method04\"]]$u2,\n        MethodsBlock[[\"method05\"]]$u2,\n        MethodsBlock[[\"method06\"]]$u2,\n        MethodsBlock[[\"method07\"]]$u2,\n        MethodsBlock[[\"method08\"]]$u2,\n        MethodsBlock[[\"method09\"]]$u2,\n        MethodsBlock[[\"method10\"]]$u2,\n#        main=\"U2\",\n        names=c(\"Boot\", 1:10),\n        col=\"grey\"\n)\nabline(v=1.5, lwd=2)\nabline(h=mean(MethodsBlock[[\"methodboot\"]]$u2), lty=\"dashed\")\n\nscreen(3)\n\n# Distribution of differences\nvioplot(with(MethodsBlock[[\"methodboot\"]], (u1 - u2)),\n        with(MethodsBlock[[\"method01\"]], (u1 - u2)),\n        with(MethodsBlock[[\"method02\"]], (u1 - u2)),\n        with(MethodsBlock[[\"method03\"]], (u1 - u2)),\n        with(MethodsBlock[[\"method04\"]], (u1 - u2)),\n        with(MethodsBlock[[\"method05\"]], (u1 - u2)),\n        with(MethodsBlock[[\"method06\"]], (u1 - u2)),\n        with(MethodsBlock[[\"method07\"]], (u1 - u2)),\n        with(MethodsBlock[[\"method08\"]], (u1 - u2)),\n        with(MethodsBlock[[\"method09\"]], (u1 - u2)),\n        with(MethodsBlock[[\"method10\"]], (u1 - u2)),\n#        xlab=\"U1 - U2\",\n        lwd=1.5,\n        names=c(\"Boot\", 1:10),\n        col=\"grey\"\n)\nabline(v=1.5, lwd=2)\nabline(h=mean(with(MethodsBlock[[\"methodboot\"]], (u1 - u2))), lty=\"dashed\")\nabline(h=0)\nclose.screen(all.screens=T)\ndev.off()\n\n############################################################################################\n######### SUPPLEMENTARY ANALYSIS ###########################################################\n############################################################################################\n\n\nU1.mean <- 0.600\nU2.mean <- 0.542\n\nU1.sd <- 0.100\nU2.sd <- 0.120\n\nU1.N <- 80\nU2.N <- 15\n\nU1.se <- U1.sd / U1.N^0.5\nU2.se <- U2.sd / U2.N^0.5\n\nalt.U1.summary <- list(mu=U1.mean, sd=U1.se)\nalt.U2.summary <- list(mu=U2.mean, sd=U2.se)\n\n\n\n#plot(u2 ~ u1, data=PSA.method09)\n# Method 8 & 9\n\ntmp  <- MakeBCVR.2d(alt.U1.summary$mu, alt.U1.summary$sd, alt.U2.summary$mu, alt.U2.summary$sd, n.psa=n.PSA, incBy=0.00001, upper=F)\ntmp2  <- MakeBCVR.2d(alt.U1.summary$mu, alt.U1.summary$sd, alt.U2.summary$mu, alt.U2.summary$sd, n.psa=n.PSA, incBy=0.00001, upper=T)\n\n\nPSA.method08.newData <-data.frame(tmp$samples)\nnames(PSA.method08.newData) <- c(\"u1\", \"u2\")\n\nmethod08.cov <- tmp$cov\nmethod08.cor <- tmp$cor\n\nmethod09.cov <- tmp2$cov\nmethod09.cor <- tmp2$cor\n\nPSA.method09.newData <- data.frame(tmp2$samples)\nnames(PSA.method09.newData) <- c(\"u1\", \"u2\")\n\n\n# METHOD 10: Beta distribution difference fitting\n\ntmp <- getDifParam(alt.U1.summary$mu, alt.U1.summary$sd, alt.U2.summary$mu, alt.U2.summary$sd, F)\n\nn.PSA <- 1000\n\nalt.u1.param <- estBeta(alt.U1.summary$mu, alt.U1.summary$sd^2)\nalt.u2.param <- estBeta(alt.U2.summary$mu, alt.U2.summary$sd^2)\n\n\n#rU2.raw <- rnorm(n.PSA, U2.summary$mu, U2.summary$sd)\nrU2.raw <- rbeta(n.PSA, u2.param$a, u2.param$b)\n#rU1 <- rnorm(n.PSA, U1.summary$mu, U1.summary$sd)\nrU1 <- rbeta(n.PSA, u1.param$a, u1.param$b)\nrdelta<-rbeta(n.PSA,tmp$a,tmp$b)\nrU2<-rU1-rdelta\n\n\n\n# png(\"DensCompare.png\", 500, 500)\n# dev.off()\n\n\nPSA.method10.newData <- data.frame(u1 = rU1, u2=rU2)\n\n# plot(u2 ~ u1, data=PSA.method10.newData, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),  main=\"Method 10\")\n# abline(0,1)\n\n\ntiff(\"Fig6 PSA_alt.tiff\", 800, 800)\n\nsplit.screen(c(2,2))\n\nscreen(1)\nplot(density(rU1), \n     xlim=c(0.4, 0.7), \n     ylim=c(0,20), \n     main=\"a) Density plot\", \n     xlab=expression(italic(U)), \n     ylab=\"Density\")\nlines(density(rU2), lty=\"dashed\")\nlines(density(rU2.raw), lwd=2, lty=\"dashed\")\nlegend(\"topleft\", \n       legend=c(\n         expression(italic(U)[1]), \n         expression(italic(U)[1]^'*'), \n         expression(italic(U)[2])\n         ), \n       lwd=c(1,1,2), \n       lty=c(\"solid\", \"dashed\", \"dashed\"))\n\n\nscreen(2)\nplot(u2 ~ u1, data=PSA.method08.newData, \n     xlim=c(0.45, 0.7), ylim=c(0.45,0.7),  \n     xlab=expression(italic(U)[1]),\n     ylab=expression(italic(U)[2]),\n     main=\"b) Method 8\")\nabline(0,1)\n\nscreen(3)\nplot(u2 ~ u1, data=PSA.method09.newData, \n     xlab=expression(italic(U)[1]),\n     ylab=expression(italic(U)[2]),\n     xlim=c(0.45, 0.7), ylim=c(0.45,0.7),  main=\"c) Method 9\")\nabline(0,1)\n\nscreen(4)\nplot(u2 ~ u1, data=PSA.method10.newData, \n     xlab=expression(italic(U)[1]),\n     ylab=expression(italic(U)[2]),\n     xlim=c(0.45, 0.7), ylim=c(0.45,0.7),  main=\"d) Method 10\")\nabline(0,1)\n\n\nclose.screen(1:4, T)\n\ndev.off()\n\n\n\n##############################################################################\n##############################################################################\n# Code below if producing the above graphs independently.\n#png(\"PSA_boot.png\",300, 300)\n\n#plot(u2 ~ u1, data=MethodsBlock$methodboot, xlim=c(0.45, 0.7), ylim=c(0.45,0.7), main=\"Bootstrapped\")\n#abline(0,1)\n#dev.off()\n\npng(\"PSA_m01.png\",300, 300)\nplot(u2 ~ u1, data=MethodsBlock$method01, xlim=c(0.45, 0.7), ylim=c(0.45,0.7), cex.main=0.6, main=\"Method 1\")\nabline(0,1)\ndev.off()\n\npng(\"PSA_m02.png\",300, 300)\nplot(u2 ~ u1, data=MethodsBlock$method02, xlim=c(0.45, 0.7), ylim=c(0.45,0.7), main=\"Method 2\")\nabline(0,1)\ndev.off()\n\npng(\"PSA_m03.png\", 300, 300)\nplot(u2 ~ u1, data=MethodsBlock$method03, xlim=c(0.45, 0.7), ylim=c(0.45,0.7), main=\"Method 3\")\nabline(0,1)\ndev.off()\n\npng(\"PSA_m04.png\", 300, 300)\nplot(u2 ~ u1, data=MethodsBlock$method04, xlim=c(0.45, 0.7), ylim=c(0.45,0.7), main=\"Method 4\")\nabline(0,1)\ndev.off()\n\npng(\"PSA_m05.png\", 300, 300)\nplot(u2 ~ u1, data=MethodsBlock$method05, xlim=c(0.45, 0.7), ylim=c(0.45,0.7), main=\"Method 5\")\nabline(0,1)\ndev.off()\n\npng(\"PSA_m06.png\", 300, 300)\nplot(u2 ~ u1, data=MethodsBlock$method06, xlim=c(0.45, 0.7), ylim=c(0.45,0.7), main=\"Method 6\")\nabline(0,1)\ndev.off()\n\npng(\"PSA_m07.png\", 300, 300)\nplot(u2 ~ u1, data=MethodsBlock$method07, xlim=c(0.45, 0.7), ylim=c(0.45,0.7), main=\"Method 7\")\nabline(0,1)\ndev.off()\n\npng(\"PSA_m08.png\", 300, 300)\nplot(u2 ~ u1, data=MethodsBlock$method08, xlim=c(0.45, 0.7), ylim=c(0.45,0.7), main=\"Method 8\")\nabline(0,1)\ndev.off()\n\npng(\"PSA_m09.png\", 300, 300)\nplot(u2 ~ u1, data=MethodsBlock$method09, xlim=c(0.45, 0.7), ylim=c(0.45,0.7), main=\"Method 9\")\nabline(0,1)\ndev.off()\n\npng(\"PSA_m10.png\", 300, 300)\nplot(u2 ~ u1, data=MethodsBlock$method10, xlim=c(0.45, 0.7), ylim=c(0.45,0.7), main=\"Method 10\")\nabline(0,1)\ndev.off()\n\n######################################################################\n\n#### IGNORE WHAT I HAVE BELOW:\n\n\n# What I want:\n\n# 1) Proportion of draws where monotonicity is violated\n# 2) Mean value of U1\n# 3) Mean value of U2\n# 4) Mean of U1 - U2\n# 3)\n# VIOLATION OF MONOTONICITY\n\n# 1) Proportion of draws where monotonicity is violated\n\nPropViolations <- function(x){\n  return(length(which(x[,1] < x[,2])))\n}\n\nsapply(MethodsBlock, PropViolations)\n\n# 2) Mean value of U1\n# 3) Mean value of U2\n\ntmp <- sapply(MethodsBlock, colMeans)\n\npng(\"MeanScatter.png\", 400, 400)\nplot(NA, ylab=\"u2\", xlab=\"u1\", xlim=c(0.595, 0.605), ylim=c(0.545, 0.555))\n\npoints(tmp[2,1] ~ tmp[1,1], cex=3, pch=4, lwd=3)\n\nfor (i in 2:11){\n  points(tmp[2,i] ~ tmp[1,i], pch=i)\n}\n\nlegend(\"topleft\", legend=c(\"Bootstrap\", 1:10), pch=c(4, 1:10))\ndev.off()\n\ntmp.difs <- rep(NA, 10)\nfor (i in 1:10){\n  tmp.difs[i] <- (\n    (tmp[1,i+1] - tmp[1,1])^2\n  + (tmp[2,i+1] - tmp[2,1])^2\n    )^0.5\n  }\npng(\"SdScatter.png\", 400, 400)\ntmp2 <- sapply(MethodsBlock, function(x) apply(x, 2, sd))\n\nplot(NA, \n     ylab=expression(italic(U)[2]), \n     xlab=expression(italic(U)[1]), \n     xlim=c(0.02, .024), \n     ylim=c(00.02, .024))\n\npoints(tmp2[2,1] ~ tmp2[1,1], cex=3, pch=4, lwd=3)\n\nfor (i in 2:11){\n  points(tmp2[2,i] ~ tmp2[1,i], pch=i)\n}\n\nlegend(\"bottomright\", legend=c(\"Bootstrap\", 1:10), pch=c(4, 1:10))\ndev.off()\n\ntmp2.difs <- rep(NA, 10)\nfor (i in 1:10){\n  tmp2.difs[i] <- (\n    (tmp2[1,i+1] - tmp2[1,1])^2\n    + (tmp2[2,i+1] - tmp2[2,1])^2\n  )^0.5\n}\n\ntmp3 <- sapply(MethodsBlock, function(x) (cov(x)[2,1]))\ntmp3.difs <- rep(NA, 10)\nfor (i in 1:10){tmp3.difs[i] <- abs(tmp3[i+1] - tmp3[1]) }\n\ntmp4 <- sapply(MethodsBlock, function(x) (cor(x)[2,1]))\ntmp4.difs <- rep(NA, 10)\nfor (i in 1:10){tmp4.difs[i] <- abs(tmp4[i+1] - tmp4[1]) }\n\n# 4) Mean of U1 - U2\n\n# now what is the distribution of differences u1 - u2?\n\ndifsDist <- matrix(NA, nrow=n.PSA, ncol=11)\n\nfor (i in 1:11){\n  difsDist[,i] <- MethodsBlock[[i]][,1] - MethodsBlock[[i]][,2]\n}\n\nnames.quants.interest <- c(\"min\", \"lower\", \"median\", \"mean\", \"upper\", \"max\")\nquants.of.interest <- matrix(NA, nrow=length(names.quants.interest), ncol=11)\nrownames(quants.of.interest) <- names.quants.interest\nfor (i in 1:11){\n  quants.of.interest[\"min\", i] <- min(difsDist[,i])\n  quants.of.interest[c(\"lower\", \"median\", \"upper\"),i] <- quantile(difsDist[,i], c(0.025, 0.5, 0.975))\n  quants.of.interest[\"max\", i] <- max(difsDist[,i])\n  quants.of.interest[\"mean\", i] <- mean(difsDist[,i])\n}\n\ncolnames(quants.of.interest) <- c(\"boot\", 1:10)\n",
    "created" : 1399948237088.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "691796754",
    "id" : "B40A8AC5",
    "lastKnownWriteTime" : 1391719730,
    "path" : "~/Google Drive/R_Projects/Monotonicity/Existing_Material/Code/R/ReanalysisScript_Beta.R",
    "project_path" : "Existing_Material/Code/R/ReanalysisScript_Beta.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}