mu.Y=U2.summary$mu,
sd.Y=U2.summary$sd,
upper=F
)$samples
PSA.2d.method09 <- MakeBCVR.2d(
mu.X=U1.summary$mu,
sd.X=U1.summary$sd,
mu.Y=U2.summary$mu,
sd.Y=U2.summary$sd
)$samples
# METHOD 10: Beta distribution difference fitting
# Some functions borrowed from myself
# Find the sum of squares:
SumSquaredFinder <- function(real.values, predicted.values){
squared.errors <- (real.values - predicted.values)^2
return(sum(squared.errors))
}
FitCompare <- function(par, PSA.X, PSA.Y){
shape1 <- exp(par[1])
shape2 <- exp(par[2])
n.psa <- length(PSA.X)
additional <- rbeta(n.psa, shape1, shape2)
#  cat(head(additional), "\n")
#  cat(shape1, shape2, "\n")
Sims.Y <- PSA.X + additional
sumSquared <- SumSquaredFinder(real.values=PSA.Y, predicted.values=Sims.Y)
#  cat("sumSquared=", sumSquared, "\n")
#  browser()
return(sumSquared)
}
OptimFitFinder <- function(PSA.X, PSA.Y, initial.shape1, initial.shape2){
n.psa <- length(PSA.X)
optim.out <- optim(par=c(log(initial.shape1), log(initial.shape2)), FitCompare, PSA.X=PSA.X, PSA.Y=PSA.Y,
method="SANN", hessian=T, control=list(trace=10))
return(optim.out)
}
sims.U1 <- rnorm(1000, mean=U1.summary$mu, sd=U1.summary$sd)
sims.U2 <- rnorm(1000, mean=U2.summary$mu, sd=U2.summary$sd)
optimOutput  <- OptimFitFinder(sims.U2, sims.U1, 3, 10)
optim.shape1 <- exp(optimOutput$par[1])
optim.shape2 <- exp(optimOutput$par[2])
plot(density(sims.U1))
lines(density(sims.U2 + rbeta(1000, increment.params[[1]], increment.params[[2]])), lwd=2)
ShowImps <- function(U1, U2, shape1, shape2){
plot(density(U1), xlim=c(0,1))
lines(density(U2), lty="dashed")
increment <- rbeta(1000, shape1, shape2)
lines(density(U2 + increment), lty="dashed", lwd=2)
return(sum((U1 - (U2 + increment))^2))
}
lines(density(sims.U2 + rbeta(1000, optim.shape1, optim.shape2)), lwd=2)
plot(density(sims.U1))
lines(density(sims.U2 + rbeta(1000, optim.shape1, optim.shape2)), lwd=2)
ShowImps(sims.U1, sims.U2, optim.shape1, optim.shape2)
ShowImps(sims.U1, sims.U2, 3, 10)
ShowImps(sims.U1, sims.U2, 5, 30)
ShowImps(sims.U1, sims.U2, 5, 50)
ShowImps(sims.U1, sims.U2, 5, 70)
ShowImps(sims.U1, sims.U2, 5, 80)
ShowImps(sims.U1, sims.U2, 4, 80)
ShowImps(sims.U1, sims.U2, 4, 100)
ShowImps(sims.U1, sims.U2, 5, 100)
ShowImps(sims.U1, sims.U2, 6, 100)
optimOutput  <- OptimFitFinder(sims.U2, sims.U1, 6, 100)
optim.shape1 <- exp(optimOutput$par[1])
optim.shape2 <- exp(optimOutput$par[2])
plot(density(sims.U1))
lines(density(sims.U2 + rbeta(1000, optim.shape1, optim.shape2)), lwd=2)
plot(sims.U2 ~ sims.U1 + rbeta(1000, optim.shape1, optim.shape2))
betas <- rbeta(1000, optim.shape1, optim.shape2)
plot(sims.U2 ~ sims.U1 + betas)
plot(sims.U2 ~ I(sims.U1 + betas)
)
plot(sims.U1 ~ I(sims.U2 + betas) )
cor(cbind(sims.U1, sims.U2 + betas))
rm(list=ls())
setwd("X:/Monotonicity/Code/R/")
load("MattData.rData")
require(MASS)
# reproduce figure 1
png("Fig1.png", 400, 400)
plot(U2 ~ U1, data=Data.2D, xlim=c(0,1), ylim=c(0,1), xlab="Utility in moderate state (U1)", ylab="Utility in severe state (U2)")
abline(0,1)
dev.off()
# What is the true variance-covariance of the datasets?
cov(Data.2D)
cor(Data.2D)
cov(Data.3D)
cor(Data.3D)
U1.summary <- list(mu=0.60, sd=(0.644 - 0.600)/1.96)
U2.summary <- list(mu=0.55, sd=(0.594 - 0.550)/1.96)
############################################################################################################################
######################## METHODS ###########################################################################################
############################################################################################################################
## Method 1 : Independent Sampling (Naive)
## Method 2 : Quantile matching/same random number seed
## Method 3 : Upward Replacement
## Method 4 : Downward Replacement
## Method 5 : Upward Resampling
## Method 6 : Downward Resampling
## Method 7 : AIVM Covariance
## Method 8 : Lower bounded covariance retrofitting
## Method 9 : Upper Bounded covariance retrofitting
## Method 10: Beta distribution difference modelling
# 2d case first, then 3d case
############################################################################################################################
# METHOD 1: INDEPENDENT SAMPLING
PSA.2d.method01 <-  data.frame(u1=rnorm(1000, mean=U1.summary$mu, sd=U1.summary$sd),
u2=rnorm(1000, mean=U2.summary$mu, sd=U2.summary$sd))
# METHOD 2: SAME RANDOM NUMBER SEED
set.seed(20)
u1 <- rnorm(1000, mean=U1.summary$mu, sd=U1.summary$sd)
set.seed(20)
u2 <- rnorm(1000, mean=U2.summary$mu, sd=U2.summary$sd)
PSA.2d.method02 <-  data.frame(u1=u1, u2=u2)
rm(u1, u2)
# METHOD 3: UPWARD REPLACEMENT
u1 <- rnorm(1000, mean=U1.summary$mu, sd=U1.summary$sd)
u2 <- rnorm(1000, mean=U2.summary$mu, sd=U2.summary$sd)
u1[u1 < u2] <- u2[u1 < u2]
PSA.2d.method03 <- data.frame(u1=u1, u2=u2)
rm(u1, u2)
# METHOD 4: DOWNWARD REPLACEMENT
u1 <- rnorm(1000, mean=U1.summary$mu, sd=U1.summary$sd)
u2 <- rnorm(1000, mean=U2.summary$mu, sd=U2.summary$sd)
u2[u2 > u1] <- u1[u2 > u1]
PSA.2d.method04 <- data.frame(u1=u1, u2=u2)
rm(u1, u2)
# METHOD 5: UPWARDS RESAMPLING
u1 <- rnorm(1000, mean=U1.summary$mu, sd=U1.summary$sd)
u2 <- rep(NA, 1000)
for (i in 1:1000){
continue <- F
while(continue==F){
this.u2 <- rnorm(1, mean=U2.summary$mu, sd=U2.summary$sd)
if (this.u2 < u1[i]){
u2[i] <- this.u2
continue <- T
}
}
}
PSA.2d.method05 <- data.frame(u1=u1, u2=u2)
rm(u1, u2)
# METHOD 6: UPWARDS RESAMPLING
u1 <- rep(NA, 1000)
u2 <- rnorm(1000, mean=U2.summary$mu, sd=U2.summary$sd)
for (i in 1:1000){
continue <- F
while(continue==F){
this.u1 <- rnorm(1, mean=U1.summary$mu, sd=U1.summary$sd)
if (this.u1 > u2[i]){
u1[i] <- this.u1
continue <- T
}
}
}
PSA.2d.method06 <- data.frame(u1=u1, u2=u2)
rm(u1, u2)
# METHOD 7: AIVM COVARIANCE
# Correlation(X, Y) := covariance (X, Y) / (sd(X) * sd(Y))
# So, when correlation = 1
# covariance(X, y) = sd(X) * sd(Y)
# This defines the upper limit on the values
# Function
MakeAIVMCov.2d <- function(mu.X, sd.X, mu.Y, sd.Y, n.psa=1000){
require(MASS)
varX <- sd.X^2
varY <- sd.Y^2
aivm <- min(
mean(
c(varX, varY)
),
sd.X * sd.Y)
sig <- matrix(data=c(varX, aivm, aivm, varY), nrow=2, byrow=T)
aivm.samples <-   mvrnorm(n=n.psa, mu=c(mu.X, mu.Y), Sigma=sig )
colnames(aivm.samples) <- c("X.sampled", "Y.sampled")
aivm.samples <- as.data.frame(aivm.samples)
return(aivm.samples)
}
PSA.2d.method07 <- MakeAIVMCov.2d(
mu.X=U1.summary$mu,
sd.X=U1.summary$sd,
mu.Y=U2.summary$mu,
sd.Y=U2.summary$sd
)
# METHOD 8: Lower Bounded Covariance Retrofitting
# METHOD 9: Upper Bounded Covariance Retrofitting
# Lowerbounded (method 8) : use upper=F
# Otherwise (method 9) use default:  upper=T
MakeBCVR.2d <- function(mu.X, sd.X, mu.Y, sd.Y, n.psa=1000, incBy=0.00001, upper=T){
require(MASS)
varX <- sd.X^2 # variance of X
varY <- sd.Y^2 # variance of Y
if(upper==T){
lowerbound <- 0 # start assuming independent
} else {
lowerbound <- mean(varX, varY)
}
upperbound <- min(sd.X * sd.Y,
mean(varX, varY)
) # upper bounds are the minimum of the AIVM or the cov which implies a cor > 1
this.cov <- lowerbound
cat(varX, varY, lowerbound, upperbound, this.cov, "\n")
mus <- c(mu.X, mu.Y)
search <- T
if(this.cov==upperbound){ # if the maximum value's been reached already
cat("Upperbound already reached\n")
search <- F # if the upper limit's already been reached, go no further
testsig <- matrix(c(varX, this.cov, this.cov, varY), nrow=2, byrow=T)
testsamples <- mvrnorm(n.psa, mu=mus, Sigma=testsig)
} else {
cat("Upperbound not yet reached\n")
this.cov <- lowerbound
cat("This covariance: ", this.cov, "\n", sep="")
testsig <- matrix(c(varX, this.cov, this.cov, varY), nrow=2, byrow=T)
testsamples <- mvrnorm(n.psa, mu=mus, Sigma=testsig)
}
while(search==T){
cat("trying ", this.cov, "\n")
testsig <- matrix(c(varX, this.cov, this.cov, varY), nrow=2, byrow=T)
try.testsamples <- try(mvrnorm(n.psa, mu=mus, Sigma=testsig))
if(class(try.testsamples)=="try-error"){ # if mvrnorm has been passed impossible values
search <- F
cat("Error picked up\n")
} else {
cat("No error in mvrnorm args\n")
testsamples <- try.testsamples # if the attempted values are correct, use them
if (any(testsamples[,1] < testsamples[,2])){
cat("Violation with ", this.cov, "\n")
this.cov <- this.cov + incBy # increment the values by a little bit
cat("Trying ", this.cov, "\n")
} else {
cat("Found ", this.cov, "\n")
search <- F
}
}
}
return(list(cov=this.cov, samples=testsamples))
}
PSA.2d.method08 <- MakeBCVR.2d(
mu.X=U1.summary$mu,
sd.X=U1.summary$sd,
mu.Y=U2.summary$mu,
sd.Y=U2.summary$sd,
upper=F
)$samples
PSA.2d.method09 <- MakeBCVR.2d(
mu.X=U1.summary$mu,
sd.X=U1.summary$sd,
mu.Y=U2.summary$mu,
sd.Y=U2.summary$sd
)$samples
# METHOD 10: Beta distribution difference fitting
# Some functions borrowed from myself
# Find the sum of squares:
SumSquaredFinder <- function(real.values, predicted.values){
squared.errors <- (real.values - predicted.values)^2
return(sum(squared.errors))
}
FitCompare <- function(par, PSA.X, PSA.Y){
shape1 <- exp(par[1])
shape2 <- exp(par[2])
n.psa <- length(PSA.X)
additional <- rbeta(n.psa, shape1, shape2)
#  cat(head(additional), "\n")
#  cat(shape1, shape2, "\n")
Sims.Y <- PSA.X + additional
sumSquared <- SumSquaredFinder(real.values=PSA.Y, predicted.values=Sims.Y)
#  cat("sumSquared=", sumSquared, "\n")
#  browser()
return(sumSquared)
}
OptimFitFinder <- function(PSA.X, PSA.Y, initial.shape1, initial.shape2){
n.psa <- length(PSA.X)
optim.out <- optim(par=c(log(initial.shape1), log(initial.shape2)), FitCompare, PSA.X=PSA.X, PSA.Y=PSA.Y,
method="SANN", hessian=T, control=list(trace=10))
return(optim.out)
}
sims.U1 <- rnorm(1000, mean=U1.summary$mu, sd=U1.summary$sd)
sims.U2 <- rnorm(1000, mean=U2.summary$mu, sd=U2.summary$sd)
optimOutput  <- OptimFitFinder(sims.U2, sims.U1, 6, 100)
optim.shape1 <- exp(optimOutput$par[1])
optim.shape2 <- exp(optimOutput$par[2])
plot(density(sims.U1))
lines(density(sims.U2 + rbeta(1000, optim.shape1, optim.shape2)), lwd=2)
ShowImps <- function(U1, U2, shape1, shape2){
plot(density(U1), xlim=c(0,1))
lines(density(U2), lty="dashed")
increment <- rbeta(1000, shape1, shape2)
lines(density(U2 + increment), lty="dashed", lwd=2)
return(sum((U1 - (U2 + increment))^2))
}
ShowImps(sims.U1, sims.U2, optim.shape1, optim.shape2)
rm(list=ls())
setwd("X:/Monotonicity/Code/R/")
load("MattData.rData")
require(MASS)
# reproduce figure 1
png("Fig1.png", 400, 400)
plot(U2 ~ U1, data=Data.2D, xlim=c(0,1), ylim=c(0,1), xlab="Utility in moderate state (U1)", ylab="Utility in severe state (U2)")
abline(0,1)
dev.off()
# What is the true variance-covariance of the datasets?
cov(Data.2D)
cor(Data.2D)
cov(Data.3D)
cor(Data.3D)
U1.summary <- list(mu=0.60, sd=(0.644 - 0.600)/1.96)
U2.summary <- list(mu=0.55, sd=(0.594 - 0.550)/1.96)
############################################################################################################################
######################## METHODS ###########################################################################################
############################################################################################################################
## Method 1 : Independent Sampling (Naive)
## Method 2 : Quantile matching/same random number seed
## Method 3 : Upward Replacement
## Method 4 : Downward Replacement
## Method 5 : Upward Resampling
## Method 6 : Downward Resampling
## Method 7 : AIVM Covariance
## Method 8 : Lower bounded covariance retrofitting
## Method 9 : Upper Bounded covariance retrofitting
## Method 10: Beta distribution difference modelling
# 2d case first, then 3d case
############################################################################################################################
# METHOD 1: INDEPENDENT SAMPLING
PSA.2d.method01 <-  data.frame(u1=rnorm(1000, mean=U1.summary$mu, sd=U1.summary$sd),
u2=rnorm(1000, mean=U2.summary$mu, sd=U2.summary$sd))
# METHOD 2: SAME RANDOM NUMBER SEED
set.seed(20)
u1 <- rnorm(1000, mean=U1.summary$mu, sd=U1.summary$sd)
set.seed(20)
u2 <- rnorm(1000, mean=U2.summary$mu, sd=U2.summary$sd)
PSA.2d.method02 <-  data.frame(u1=u1, u2=u2)
rm(u1, u2)
# METHOD 3: UPWARD REPLACEMENT
u1 <- rnorm(1000, mean=U1.summary$mu, sd=U1.summary$sd)
u2 <- rnorm(1000, mean=U2.summary$mu, sd=U2.summary$sd)
u1[u1 < u2] <- u2[u1 < u2]
PSA.2d.method03 <- data.frame(u1=u1, u2=u2)
rm(u1, u2)
# METHOD 4: DOWNWARD REPLACEMENT
u1 <- rnorm(1000, mean=U1.summary$mu, sd=U1.summary$sd)
u2 <- rnorm(1000, mean=U2.summary$mu, sd=U2.summary$sd)
u2[u2 > u1] <- u1[u2 > u1]
PSA.2d.method04 <- data.frame(u1=u1, u2=u2)
rm(u1, u2)
# METHOD 5: UPWARDS RESAMPLING
u1 <- rnorm(1000, mean=U1.summary$mu, sd=U1.summary$sd)
u2 <- rep(NA, 1000)
for (i in 1:1000){
continue <- F
while(continue==F){
this.u2 <- rnorm(1, mean=U2.summary$mu, sd=U2.summary$sd)
if (this.u2 < u1[i]){
u2[i] <- this.u2
continue <- T
}
}
}
PSA.2d.method05 <- data.frame(u1=u1, u2=u2)
rm(u1, u2)
# METHOD 6: UPWARDS RESAMPLING
u1 <- rep(NA, 1000)
u2 <- rnorm(1000, mean=U2.summary$mu, sd=U2.summary$sd)
for (i in 1:1000){
continue <- F
while(continue==F){
this.u1 <- rnorm(1, mean=U1.summary$mu, sd=U1.summary$sd)
if (this.u1 > u2[i]){
u1[i] <- this.u1
continue <- T
}
}
}
PSA.2d.method06 <- data.frame(u1=u1, u2=u2)
rm(u1, u2)
# METHOD 7: AIVM COVARIANCE
# Correlation(X, Y) := covariance (X, Y) / (sd(X) * sd(Y))
# So, when correlation = 1
# covariance(X, y) = sd(X) * sd(Y)
# This defines the upper limit on the values
# Function
MakeAIVMCov.2d <- function(mu.X, sd.X, mu.Y, sd.Y, n.psa=1000){
require(MASS)
varX <- sd.X^2
varY <- sd.Y^2
aivm <- min(
mean(
c(varX, varY)
),
sd.X * sd.Y)
sig <- matrix(data=c(varX, aivm, aivm, varY), nrow=2, byrow=T)
aivm.samples <-   mvrnorm(n=n.psa, mu=c(mu.X, mu.Y), Sigma=sig )
colnames(aivm.samples) <- c("X.sampled", "Y.sampled")
aivm.samples <- as.data.frame(aivm.samples)
return(aivm.samples)
}
PSA.2d.method07 <- MakeAIVMCov.2d(
mu.X=U1.summary$mu,
sd.X=U1.summary$sd,
mu.Y=U2.summary$mu,
sd.Y=U2.summary$sd
)
# METHOD 8: Lower Bounded Covariance Retrofitting
# METHOD 9: Upper Bounded Covariance Retrofitting
# Lowerbounded (method 8) : use upper=F
# Otherwise (method 9) use default:  upper=T
MakeBCVR.2d <- function(mu.X, sd.X, mu.Y, sd.Y, n.psa=1000, incBy=0.00001, upper=T){
require(MASS)
varX <- sd.X^2 # variance of X
varY <- sd.Y^2 # variance of Y
if(upper==T){
lowerbound <- 0 # start assuming independent
} else {
lowerbound <- mean(varX, varY)
}
upperbound <- min(sd.X * sd.Y,
mean(varX, varY)
) # upper bounds are the minimum of the AIVM or the cov which implies a cor > 1
this.cov <- lowerbound
cat(varX, varY, lowerbound, upperbound, this.cov, "\n")
mus <- c(mu.X, mu.Y)
search <- T
if(this.cov==upperbound){ # if the maximum value's been reached already
cat("Upperbound already reached\n")
search <- F # if the upper limit's already been reached, go no further
testsig <- matrix(c(varX, this.cov, this.cov, varY), nrow=2, byrow=T)
testsamples <- mvrnorm(n.psa, mu=mus, Sigma=testsig)
} else {
cat("Upperbound not yet reached\n")
this.cov <- lowerbound
cat("This covariance: ", this.cov, "\n", sep="")
testsig <- matrix(c(varX, this.cov, this.cov, varY), nrow=2, byrow=T)
testsamples <- mvrnorm(n.psa, mu=mus, Sigma=testsig)
}
while(search==T){
cat("trying ", this.cov, "\n")
testsig <- matrix(c(varX, this.cov, this.cov, varY), nrow=2, byrow=T)
try.testsamples <- try(mvrnorm(n.psa, mu=mus, Sigma=testsig))
if(class(try.testsamples)=="try-error"){ # if mvrnorm has been passed impossible values
search <- F
cat("Error picked up\n")
} else {
cat("No error in mvrnorm args\n")
testsamples <- try.testsamples # if the attempted values are correct, use them
if (any(testsamples[,1] < testsamples[,2])){
cat("Violation with ", this.cov, "\n")
this.cov <- this.cov + incBy # increment the values by a little bit
cat("Trying ", this.cov, "\n")
} else {
cat("Found ", this.cov, "\n")
search <- F
}
}
}
return(list(cov=this.cov, samples=testsamples))
}
PSA.2d.method08 <- MakeBCVR.2d(
mu.X=U1.summary$mu,
sd.X=U1.summary$sd,
mu.Y=U2.summary$mu,
sd.Y=U2.summary$sd,
upper=F
)$samples
PSA.2d.method09 <- MakeBCVR.2d(
mu.X=U1.summary$mu,
sd.X=U1.summary$sd,
mu.Y=U2.summary$mu,
sd.Y=U2.summary$sd
)$samples
# METHOD 10: Beta distribution difference fitting
# Some functions borrowed from myself
ShowImps <- function(U1, U2, shape1, shape2){
plot(density(U1), xlim=c(0,1))
lines(density(U2), lty="dashed")
increment <- rbeta(1000, shape1, shape2)
lines(density(U2 + increment), lty="dashed", lwd=2)
return(sum((U1 - (U2 + increment))^2))
}
# Use ShowImps to guess a decent enough initial value
# Find the sum of squares:
SumSquaredFinder <- function(real.values, predicted.values){
squared.errors <- (real.values - predicted.values)^2
return(sum(squared.errors))
}
FitCompare <- function(par, PSA.X, PSA.Y){
shape1 <- exp(par[1])
shape2 <- exp(par[2])
n.psa <- length(PSA.X)
additional <- rbeta(n.psa, shape1, shape2)
#  cat(head(additional), "\n")
#  cat(shape1, shape2, "\n")
Sims.Y <- PSA.X + additional
sumSquared <- SumSquaredFinder(real.values=PSA.Y, predicted.values=Sims.Y)
#  cat("sumSquared=", sumSquared, "\n")
#  browser()
return(sumSquared)
}
OptimFitFinder <- function(PSA.X, PSA.Y, initial.shape1, initial.shape2){
n.psa <- length(PSA.X)
optim.out <- optim(par=c(log(initial.shape1), log(initial.shape2)), FitCompare, PSA.X=PSA.X, PSA.Y=PSA.Y,
method="SANN", hessian=T, control=list(trace=10))
return(optim.out)
}
sims.U1 <- rnorm(1000, mean=U1.summary$mu, sd=U1.summary$sd)
sims.U2 <- rnorm(1000, mean=U2.summary$mu, sd=U2.summary$sd)
optimOutput  <- OptimFitFinder(sims.U2, sims.U1, 6, 100)
optim.shape1 <- exp(optimOutput$par[1])
optim.shape2 <- exp(optimOutput$par[2])
plot(density(sims.U1))
lines(density(sims.U2 + rbeta(1000, optim.shape1, optim.shape2)), lwd=2)
ShowImps(sims.U1, sims.U2, optim.shape1, optim.shape2)
