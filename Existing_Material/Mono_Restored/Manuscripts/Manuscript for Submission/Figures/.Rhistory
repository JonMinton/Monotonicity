u2.param$b
)
)
plot(u2 ~ u1, data=PSA.method01, xlim=c(0.45, 0.7), ylim=c(0.45,0.7))
abline(0,1)
# METHOD 2: SAME RANDOM NUMBER SEED
# Illustration of issue with random number stream and beta distribution
# non-problematic run:
set.seed(80)
u1 <- rbeta(n.PSA,
u1.param$a,
u1.param$b
)
set.seed(80)
u2 <- rbeta(n.PSA,
u2.param$a,
u2.param$b
)
PSA.method02 <-  data.frame(u1=u1, u2=u2)
rm(u1, u2)
plot(u2 ~ u1, data=PSA.method02, xlim=c(0.45, 0.7), ylim=c(0.45,0.7))
abline(0,1)
# METHOD 3: UPWARD REPLACEMENT
u1 <- rbeta(n.PSA, u1.param$a, u1.param$b)
u2 <- rbeta(n.PSA, u2.param$a, u2.param$b)
u1[u1 < u2] <- u2[u1 < u2]
PSA.method03 <- data.frame(u1=u1, u2=u2)
rm(u1, u2)
plot(u2 ~ u1, data=PSA.method03, xlim=c(0.45, 0.7), ylim=c(0.45,0.7))
abline(0,1)
# METHOD 4: DOWNWARD REPLACEMENT
u1 <- rbeta(n.PSA, u1.param$a, u1.param$b)
u2 <- rbeta(n.PSA, u2.param$a, u2.param$b)
u2[u2 > u1] <- u1[u2 > u1]
PSA.method04 <- data.frame(u1=u1, u2=u2)
rm(u1, u2)
plot(u2 ~ u1, data=PSA.method04, xlim=c(0.45, 0.7), ylim=c(0.45,0.7))
abline(0,1)
# METHOD 5: UPWARDS RESAMPLING
u1 <- rbeta(n.PSA, u1.param$a, u1.param$b)
u2 <- rep(NA, n.PSA)
for (i in 1:n.PSA){
continue <- F
while(continue==F){
this.u2 <- rbeta(1, u2.param$a, u2.param$b)
if (this.u2 < u1[i]){
u2[i] <- this.u2
continue <- T
}
}
}
PSA.method05 <- data.frame(u1=u1, u2=u2)
rm(u1, u2)
plot(u2 ~ u1, data=PSA.method05, xlim=c(0.45, 0.7), ylim=c(0.45,0.7))
abline(0,1)
# METHOD 6: DOWNWARDS RESAMPLING [?]
u1 <- rep(NA, n.PSA)
u2 <- rbeta(n.PSA, u2.param$a, u2.param$b)
for (i in 1:n.PSA){
continue <- F
while(continue==F){
this.u1 <- rbeta(1, u1.param$a, u1.param$b)
if (this.u1 > u2[i]){
u1[i] <- this.u1
continue <- T
}
}
}
PSA.method06 <- data.frame(u1=u1, u2=u2)
rm(u1, u2)
# METHOD 7: AIVM COVARIANCE
# Correlation(X, Y) := covariance (X, Y) / (sd(X) * sd(Y))
# So, when correlation = 1
# covariance(X, y) = sd(X) * sd(Y)
# This defines the upper limit on the values
# Function
require(MASS)
MakeAIVMCov.2d <- function(mu.X, sd.X, mu.Y, sd.Y, n.psa=n.PSA){
varX <- sd.X^2
varY <- sd.Y^2
aivm <- min(
mean(
c(varX, varY)
),
sd.X * sd.Y)
sig <- matrix(data=c(varX, aivm, aivm, varY), nrow=2, byrow=T)
aivm.samples <-   mvrnorm(n=n.psa, mu=c(mu.X, mu.Y), Sigma=sig )
colnames(aivm.samples) <- c("X.sampled", "Y.sampled")
aivm.samples <- as.data.frame(aivm.samples)
return(list(aivm.samples=aivm.samples, aivm=aivm))
}
tmp <- MakeAIVMCov.2d(
mu.X=U1.summary$mu,
sd.X=U1.summary$sd,
mu.Y=U2.summary$mu,
sd.Y=U2.summary$sd
)
PSA.method07 <- tmp$aivm.samples
names(PSA.method07) <- c("u1", "u2")
#plot(u2 ~ u1, data=PSA.method07)
# METHOD 8: Lower Bounded Covariance Retrofitting
# METHOD 9: Upper Bounded Covariance Retrofitting
# Lowerbounded (method 8) : use upper=F
# Otherwise (method 9) use default:  upper=T
MakeBCVR.2d <- function(mu.X, sd.X, mu.Y, sd.Y, n.psa=n.PSA, incBy=0.00001, upper=T){
require(MASS)
varX <- sd.X^2 # variance of X
varY <- sd.Y^2 # variance of Y
if(upper==T){
lowerbound <- 0 # start assuming independent
upperbound <- min(sd.X * sd.Y,
mean(varX, varY)
) # upper bounds are the minimum of the AIVM or the cov which implies a cor > 1
} else {
lowerbound <- mean(varX, varY)
upperbound <- sd.X * sd.Y # don't select a covariance which implies a correlation > 1
}
this.cov <- lowerbound
cat(varX, varY, lowerbound, upperbound, this.cov, "\n")
mus <- c(mu.X, mu.Y)
search <- T
if(this.cov==upperbound){ # if the maximum value's been reached already
cat("Upperbound already reached\n")
search <- F # if the upper limit's already been reached, go no further
testsig <- matrix(c(varX, this.cov, this.cov, varY), nrow=2, byrow=T)
testsamples <- mvrnorm(n.psa, mu=mus, Sigma=testsig)
} else {
cat("Upperbound not yet reached\n")
this.cov <- lowerbound
cat("This covariance: ", this.cov, "\n", sep="")
testsig <- matrix(c(varX, this.cov, this.cov, varY), nrow=2, byrow=T)
testsamples <- mvrnorm(n.psa, mu=mus, Sigma=testsig)
}
while(search==T){
cat("trying ", this.cov, "\n")
testsig <- matrix(c(varX, this.cov, this.cov, varY), nrow=2, byrow=T)
try.testsamples <- try(mvrnorm(n.psa, mu=mus, Sigma=testsig))
if(class(try.testsamples)=="try-error"){ # if mvrnorm has been passed impossible values
search <- F
cat("Error picked up\n")
} else {
cat("No error in mvrnorm args\n")
testsamples <- try.testsamples # if the attempted values are correct, use them
if (any(testsamples[,1] < testsamples[,2])){
cat("Violation with ", this.cov, "\n")
this.cov <- this.cov + incBy # increment the values by a little bit
cat("Trying ", this.cov, "\n")
} else {
cat("Found ", this.cov, "\n")
search <- F
}
}
}
this.cor <- this.cov / (sd.X * sd.Y)
return(list(cov=this.cov, samples=testsamples, cor=this.cor))
}
tmp <- MakeBCVR.2d(
mu.X=U1.summary$mu,
sd.X=U1.summary$sd,
mu.Y=U2.summary$mu,
sd.Y=U2.summary$sd,
upper=F
)
method08.cov <- tmp$cov
method08.cor <- tmp$cor
PSA.method08 <-data.frame(tmp$samples)
names(PSA.method08) <- c("u1", "u2")
tmp <- MakeBCVR.2d(
mu.X=U1.summary$mu,
sd.X=U1.summary$sd,
mu.Y=U2.summary$mu,
sd.Y=U2.summary$sd
)
method09.cov <- tmp$cov
method09.cor <- tmp$cor
PSA.method09 <- data.frame(tmp$samples)
names(PSA.method09) <- c("u1", "u2")
plot(u2 ~ u1, data=PSA.method08)
plot(u2 ~ u1, data=PSA.method09)
# METHOD 10: Beta distribution difference fitting
getDifParam <- function(u1.mu, u1.sd, u2.mu, u2.sd, quietly=T){
mu <- u1.mu - u2.mu
sigma2 <- ifelse(u1.sd > u2.sd, u1.sd^2 - u2.sd^2, u2.sd^2 - u1.sd^2)
x <- (1 - mu) / mu
a <- (x/sigma2-1-2*x-x^2)/(1+3*x+3*x^2+x^3)
b<-a*x
if(quietly==F){
print(a/(a+b))  # check mean of delta
print(a*b/(a+b)^2/(a+b+1))  # check variance of delta
}
return(list(a=a, b=b))
}
DifParams <- getDifParam(U1.summary$mu, U1.summary$sd, U2.summary$mu, U2.summary$sd)
n.PSA <- 1000
#rU2.raw <- rnorm(n.PSA, U2.summary$mu, U2.summary$sd)
rU2.raw <- rbeta(n.PSA, u2.param$a, u2.param$b)
#rU1 <- rnorm(n.PSA, U1.summary$mu, U1.summary$sd)
rU1 <- rbeta(n.PSA, u1.param$a, u1.param$b)
rdelta<-rbeta(n.PSA,DifParams$a,DifParams$b)
rU2<-rU1-rdelta
tiff("Fig3 Dif_comparison.tiff", 500, 500)
plot(
density(rU1),
xlim=c(0.4, 0.7),
ylim=c(0,20),
main="",
xlab=expression(italic(U)),
ylab="Density of simulated values")
lines(density(rU2), lty="dashed")
lines(density(rU2.raw), lwd=2, lty="dashed")
legend("topleft",
legend=c(
expression(italic(U)[1]),
expression(paste(italic(U)[2], " using difference method")),
expression(paste(italic(U)[2], " using independent sampling"))
),
lwd=c(1,1,2),
lty=c("solid", "dashed", "dashed"))
dev.off()
PSA.method10 <- data.frame(u1 = rU1, u2=rU2)
####################################### RESULTS ############################################
# want to plot scatter
# want bootstrapped estimates of means to compare
# packaging results together in list to make them easier to automate
MethodsBlock <- list(
methodboot=methodBoot.PSA,
method01=PSA.method01,
method02=PSA.method02,
method03=PSA.method03,
method04=PSA.method04,
method05=PSA.method05,
method06=PSA.method06,
method07=PSA.method07,
method08=PSA.method08,
method09=PSA.method09,
method10=PSA.method10)
# scatterplots
# do this as a single file
tiff("Fig4 PSA_all.tiff", 900, 1200)
split.screen(c(4,3))
screen(1)
plot(u2 ~ u1, data=MethodsBlock$methodboot, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),
xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),
main="a) Bootstrapped")
abline(0,1)
screen(3)
plot(u2 ~ u1, data=MethodsBlock$method01, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),
xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),
main="b) Method 1")
abline(0,1)
screen(4)
plot(u2 ~ u1, data=MethodsBlock$method02, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),
xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),
main="c) Method 2")
abline(0,1)
screen(5)
plot(u2 ~ u1, data=MethodsBlock$method03, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),
xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),
main="d) Method 3")
abline(0,1)
screen(6)
plot(u2 ~ u1, data=MethodsBlock$method04, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),
xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),
main="e) Method 4")
abline(0,1)
screen(7)
plot(u2 ~ u1, data=MethodsBlock$method05, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),
xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),
main="f) Method 5")
abline(0,1)
screen(8)
plot(u2 ~ u1, data=MethodsBlock$method06, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),
xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),
main="g) Method 6")
abline(0,1)
screen(9)
plot(u2 ~ u1, data=MethodsBlock$method07, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),
xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),
main="h) Method 7")
abline(0,1)
screen(10)
plot(u2 ~ u1, data=MethodsBlock$method08, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),
xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),
main="i) Method 8")
abline(0,1)
screen(11)
plot(u2 ~ u1, data=MethodsBlock$method09, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),
xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),
main="j) Method 9")
abline(0,1)
screen(12)
plot(u2 ~ u1, data=MethodsBlock$method10, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),
xlab=expression(italic(U)[1]), ylab=expression(italic(U)[2]),
main="k) Method 10")
abline(0,1)
close.screen(1:12, T)
dev.off()
# # VIOLIN PLOTS
#
# require(vioplot)
#
# # Distribution of U1s
# tiff("Fig5 Vioplot_u1.tiff", 1000, 800)
# vioplot(MethodsBlock[["methodboot"]]$u1,
#         MethodsBlock[["method01"]]$u1,
#         MethodsBlock[["method02"]]$u1,
#         MethodsBlock[["method03"]]$u1,
#         MethodsBlock[["method04"]]$u1,
#         MethodsBlock[["method05"]]$u1,
#         MethodsBlock[["method06"]]$u1,
#         MethodsBlock[["method07"]]$u1,
#         MethodsBlock[["method08"]]$u1,
#         MethodsBlock[["method09"]]$u1,
#         MethodsBlock[["method10"]]$u1,
#
#         names=c("Boot", 1:10),
#         col="grey"
#         )
# abline(v=1.5, lwd=2)
# abline(h=mean(MethodsBlock[["methodboot"]]$u1), lty="dashed")
# dev.off()
#
# # Distribution of U2s
# tiff("Fig6 Vioplot_u2.png", 1000, 800)
# vioplot(MethodsBlock[["methodboot"]]$u2,
#         MethodsBlock[["method01"]]$u2,
#         MethodsBlock[["method02"]]$u2,
#         MethodsBlock[["method03"]]$u2,
#         MethodsBlock[["method04"]]$u2,
#         MethodsBlock[["method05"]]$u2,
#         MethodsBlock[["method06"]]$u2,
#         MethodsBlock[["method07"]]$u2,
#         MethodsBlock[["method08"]]$u2,
#         MethodsBlock[["method09"]]$u2,
#         MethodsBlock[["method10"]]$u2,
#
#         names=c("Boot", 1:10),
#         col="grey"
# )
# abline(v=1.5, lwd=2)
# abline(h=mean(MethodsBlock[["methodboot"]]$u2), lty="dashed")
# dev.off()
#
#
# # Distribution of differences
# tiff("Fig7 Vioplot_difs.png", 1000, 800)
# vioplot(with(MethodsBlock[["methodboot"]], (u1 - u2)),
#         with(MethodsBlock[["method01"]], (u1 - u2)),
#         with(MethodsBlock[["method02"]], (u1 - u2)),
#         with(MethodsBlock[["method03"]], (u1 - u2)),
#         with(MethodsBlock[["method04"]], (u1 - u2)),
#         with(MethodsBlock[["method05"]], (u1 - u2)),
#         with(MethodsBlock[["method06"]], (u1 - u2)),
#         with(MethodsBlock[["method07"]], (u1 - u2)),
#         with(MethodsBlock[["method08"]], (u1 - u2)),
#         with(MethodsBlock[["method09"]], (u1 - u2)),
#         with(MethodsBlock[["method10"]], (u1 - u2)),
#
#         lwd=1.5,
#         names=c("Boot", 1:10),
#         col="grey"
# )
# abline(v=1.5, lwd=2)
# abline(h=mean(with(MethodsBlock[["methodboot"]], (u1 - u2))), lty="dashed")
# abline(h=0)
# dev.off()
# Violin plots as one image
require(vioplot)
tiff("Fig5 Vioplot_all.tiff", 1000, 1500)
split.screen(c(3,1))
screen(1)
# Distribution of U1s
vioplot(MethodsBlock[["methodboot"]]$u1,
MethodsBlock[["method01"]]$u1,
MethodsBlock[["method02"]]$u1,
MethodsBlock[["method03"]]$u1,
MethodsBlock[["method04"]]$u1,
MethodsBlock[["method05"]]$u1,
MethodsBlock[["method06"]]$u1,
MethodsBlock[["method07"]]$u1,
MethodsBlock[["method08"]]$u1,
MethodsBlock[["method09"]]$u1,
MethodsBlock[["method10"]]$u1,
#        main="U1",
names=c("Boot", 1:10),
col="grey"
)
abline(v=1.5, lwd=2)
abline(h=mean(MethodsBlock[["methodboot"]]$u1), lty="dashed")
screen(2)
# Distribution of U2s
vioplot(MethodsBlock[["methodboot"]]$u2,
MethodsBlock[["method01"]]$u2,
MethodsBlock[["method02"]]$u2,
MethodsBlock[["method03"]]$u2,
MethodsBlock[["method04"]]$u2,
MethodsBlock[["method05"]]$u2,
MethodsBlock[["method06"]]$u2,
MethodsBlock[["method07"]]$u2,
MethodsBlock[["method08"]]$u2,
MethodsBlock[["method09"]]$u2,
MethodsBlock[["method10"]]$u2,
#        main="U2",
names=c("Boot", 1:10),
col="grey"
)
abline(v=1.5, lwd=2)
abline(h=mean(MethodsBlock[["methodboot"]]$u2), lty="dashed")
screen(3)
# Distribution of differences
vioplot(with(MethodsBlock[["methodboot"]], (u1 - u2)),
with(MethodsBlock[["method01"]], (u1 - u2)),
with(MethodsBlock[["method02"]], (u1 - u2)),
with(MethodsBlock[["method03"]], (u1 - u2)),
with(MethodsBlock[["method04"]], (u1 - u2)),
with(MethodsBlock[["method05"]], (u1 - u2)),
with(MethodsBlock[["method06"]], (u1 - u2)),
with(MethodsBlock[["method07"]], (u1 - u2)),
with(MethodsBlock[["method08"]], (u1 - u2)),
with(MethodsBlock[["method09"]], (u1 - u2)),
with(MethodsBlock[["method10"]], (u1 - u2)),
#        xlab="U1 - U2",
lwd=1.5,
names=c("Boot", 1:10),
col="grey"
)
abline(v=1.5, lwd=2)
abline(h=mean(with(MethodsBlock[["methodboot"]], (u1 - u2))), lty="dashed")
abline(h=0)
close.screen(all.screens=T)
dev.off()
############################################################################################
######### SUPPLEMENTARY ANALYSIS ###########################################################
############################################################################################
U1.mean <- 0.600
U2.mean <- 0.542
U1.sd <- 0.100
U2.sd <- 0.120
U1.N <- 80
U2.N <- 15
U1.se <- U1.sd / U1.N^0.5
U2.se <- U2.sd / U2.N^0.5
alt.U1.summary <- list(mu=U1.mean, sd=U1.se)
alt.U2.summary <- list(mu=U2.mean, sd=U2.se)
#plot(u2 ~ u1, data=PSA.method09)
# Method 8 & 9
tmp  <- MakeBCVR.2d(alt.U1.summary$mu, alt.U1.summary$sd, alt.U2.summary$mu, alt.U2.summary$sd, n.psa=n.PSA, incBy=0.00001, upper=F)
tmp2  <- MakeBCVR.2d(alt.U1.summary$mu, alt.U1.summary$sd, alt.U2.summary$mu, alt.U2.summary$sd, n.psa=n.PSA, incBy=0.00001, upper=T)
PSA.method08.newData <-data.frame(tmp$samples)
names(PSA.method08.newData) <- c("u1", "u2")
method08.cov <- tmp$cov
method08.cor <- tmp$cor
method09.cov <- tmp2$cov
method09.cor <- tmp2$cor
PSA.method09.newData <- data.frame(tmp2$samples)
names(PSA.method09.newData) <- c("u1", "u2")
# METHOD 10: Beta distribution difference fitting
tmp <- getDifParam(alt.U1.summary$mu, alt.U1.summary$sd, alt.U2.summary$mu, alt.U2.summary$sd, F)
n.PSA <- 1000
alt.u1.param <- estBeta(alt.U1.summary$mu, alt.U1.summary$sd^2)
alt.u2.param <- estBeta(alt.U2.summary$mu, alt.U2.summary$sd^2)
#rU2.raw <- rnorm(n.PSA, U2.summary$mu, U2.summary$sd)
rU2.raw <- rbeta(n.PSA, u2.param$a, u2.param$b)
#rU1 <- rnorm(n.PSA, U1.summary$mu, U1.summary$sd)
rU1 <- rbeta(n.PSA, u1.param$a, u1.param$b)
rdelta<-rbeta(n.PSA,tmp$a,tmp$b)
rU2<-rU1-rdelta
# png("DensCompare.png", 500, 500)
# dev.off()
PSA.method10.newData <- data.frame(u1 = rU1, u2=rU2)
# plot(u2 ~ u1, data=PSA.method10.newData, xlim=c(0.45, 0.7), ylim=c(0.45,0.7),  main="Method 10")
# abline(0,1)
tiff("Fig6 PSA_alt.tiff", 800, 800)
split.screen(c(2,2))
screen(1)
plot(density(rU1),
xlim=c(0.4, 0.7),
ylim=c(0,20),
main="a) Density plot",
xlab=expression(italic(U)),
ylab="Density")
lines(density(rU2), lty="dashed")
lines(density(rU2.raw), lwd=2, lty="dashed")
legend("topleft",
legend=c(
expression(italic(U)[1]),
expression(italic(U)[1]^'*'),
expression(italic(U)[2])
),
lwd=c(1,1,2),
lty=c("solid", "dashed", "dashed"))
screen(2)
plot(u2 ~ u1, data=PSA.method08.newData,
xlim=c(0.45, 0.7), ylim=c(0.45,0.7),
xlab=expression(italic(U)[1]),
ylab=expression(italic(U)[2]),
main="b) Method 8")
abline(0,1)
screen(3)
plot(u2 ~ u1, data=PSA.method09.newData,
xlab=expression(italic(U)[1]),
ylab=expression(italic(U)[2]),
xlim=c(0.45, 0.7), ylim=c(0.45,0.7),  main="c) Method 9")
abline(0,1)
screen(4)
plot(u2 ~ u1, data=PSA.method10.newData,
xlab=expression(italic(U)[1]),
ylab=expression(italic(U)[2]),
xlim=c(0.45, 0.7), ylim=c(0.45,0.7),  main="d) Method 10")
abline(0,1)
close.screen(1:4, T)
dev.off()
